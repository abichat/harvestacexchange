"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const childProcess = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
const readline = require("readline");
const removeFolder = require("rimraf");
const util = require("util");
const helper_1 = require("../helper");
const removeFolderAsync = util.promisify(removeFolder);
const mkdtempAsync = util.promisify(fs.mkdtemp);
const DOWNLOADS_FOLDER = path.join(os.tmpdir(), 'playwright_downloads-');
const browserLog = {
    name: 'browser',
};
const browserStdOutLog = {
    name: 'browser:out',
};
const browserStdErrLog = {
    name: 'browser:err',
    severity: 'warning'
};
async function launchProcess(options) {
    const logger = options.logger;
    const stdio = options.pipe ? ['ignore', 'pipe', 'pipe', 'pipe', 'pipe'] : ['ignore', 'pipe', 'pipe'];
    logger._log(browserLog, `<launching> ${options.executablePath} ${options.args.join(' ')}`);
    const spawnedProcess = childProcess.spawn(options.executablePath, options.args, {
        // On non-windows platforms, `detached: true` makes child process a leader of a new
        // process group, making it possible to kill child process tree with `.kill(-pid)` command.
        // @see https://nodejs.org/api/child_process.html#child_process_options_detached
        detached: process.platform !== 'win32',
        env: options.env,
        stdio
    });
    if (!spawnedProcess.pid) {
        let reject;
        const result = new Promise((f, r) => reject = r);
        spawnedProcess.once('error', error => {
            reject(new Error('Failed to launch browser: ' + error));
        });
        return result;
    }
    logger._log(browserLog, `<launched> pid=${spawnedProcess.pid}`);
    const stdout = readline.createInterface({ input: spawnedProcess.stdout });
    stdout.on('line', (data) => {
        logger._log(browserStdOutLog, data);
    });
    const stderr = readline.createInterface({ input: spawnedProcess.stderr });
    stderr.on('line', (data) => {
        logger._log(browserStdErrLog, data);
    });
    const downloadsPath = await mkdtempAsync(DOWNLOADS_FOLDER);
    let processClosed = false;
    const waitForProcessToClose = new Promise((fulfill, reject) => {
        spawnedProcess.once('exit', (exitCode, signal) => {
            logger._log(browserLog, `<process did exit ${exitCode}, ${signal}>`);
            processClosed = true;
            helper_1.helper.removeEventListeners(listeners);
            options.onkill(exitCode, signal);
            // Cleanup as processes exit.
            Promise.all([
                removeFolderAsync(downloadsPath),
                options.tempDir ? removeFolderAsync(options.tempDir) : Promise.resolve()
            ]).catch((err) => console.error(err)).then(fulfill);
        });
    });
    const listeners = [helper_1.helper.addEventListener(process, 'exit', killProcess)];
    if (options.handleSIGINT) {
        listeners.push(helper_1.helper.addEventListener(process, 'SIGINT', () => {
            gracefullyClose().then(() => process.exit(130));
        }));
    }
    if (options.handleSIGTERM)
        listeners.push(helper_1.helper.addEventListener(process, 'SIGTERM', gracefullyClose));
    if (options.handleSIGHUP)
        listeners.push(helper_1.helper.addEventListener(process, 'SIGHUP', gracefullyClose));
    let gracefullyClosing = false;
    async function gracefullyClose() {
        // We keep listeners until we are done, to handle 'exit' and 'SIGINT' while
        // asynchronously closing to prevent zombie processes. This might introduce
        // reentrancy to this function, for example user sends SIGINT second time.
        // In this case, let's forcefully kill the process.
        if (gracefullyClosing) {
            logger._log(browserLog, `<forecefully close>`);
            killProcess();
            return;
        }
        gracefullyClosing = true;
        logger._log(browserLog, `<gracefully close start>`);
        await options.attemptToGracefullyClose().catch(() => killProcess());
        await waitForProcessToClose;
        logger._log(browserLog, `<gracefully close end>`);
    }
    // This method has to be sync to be used as 'exit' event handler.
    function killProcess() {
        logger._log(browserLog, `<kill>`);
        helper_1.helper.removeEventListeners(listeners);
        if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
            // Force kill the browser.
            try {
                if (process.platform === 'win32')
                    childProcess.execSync(`taskkill /pid ${spawnedProcess.pid} /T /F`);
                else
                    process.kill(-spawnedProcess.pid, 'SIGKILL');
            }
            catch (e) {
                // the process might have already stopped
            }
        }
        // Attempt to remove temporary profile directory to avoid littering.
        try {
            if (options.tempDir)
                removeFolder.sync(options.tempDir);
        }
        catch (e) { }
    }
    return { launchedProcess: spawnedProcess, gracefullyClose, downloadsPath };
}
exports.launchProcess = launchProcess;
function waitForLine(process, inputStream, regex, timeout, timeoutError) {
    return new Promise((resolve, reject) => {
        const rl = readline.createInterface({ input: inputStream });
        let stderr = '';
        const listeners = [
            helper_1.helper.addEventListener(rl, 'line', onLine),
            helper_1.helper.addEventListener(rl, 'close', () => onClose()),
            helper_1.helper.addEventListener(process, 'exit', () => onClose()),
            helper_1.helper.addEventListener(process, 'error', error => onClose(error))
        ];
        const timeoutId = timeout ? setTimeout(onTimeout, timeout) : 0;
        function onClose(error) {
            cleanup();
            reject(new Error([
                'Failed to launch browser!' + (error ? ' ' + error.message : ''),
                stderr,
                '',
                'TROUBLESHOOTING: https://github.com/Microsoft/playwright/blob/master/docs/troubleshooting.md',
                '',
            ].join('\n')));
        }
        function onTimeout() {
            cleanup();
            reject(timeoutError);
        }
        function onLine(line) {
            stderr += line + '\n';
            const match = line.match(regex);
            if (!match)
                return;
            cleanup();
            resolve(match);
        }
        function cleanup() {
            if (timeoutId)
                clearTimeout(timeoutId);
            helper_1.helper.removeEventListeners(listeners);
        }
    });
}
exports.waitForLine = waitForLine;
//# sourceMappingURL=processLauncher.js.map