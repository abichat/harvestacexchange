"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("./helper");
class ExecutionContext {
    constructor(delegate, logger) {
        this._delegate = delegate;
        this._logger = logger;
    }
    _doEvaluateInternal(returnByValue, waitForNavigations, pageFunction, ...args) {
        return this._delegate.evaluate(this, returnByValue, pageFunction, ...args);
    }
    _adoptIfNeeded(handle) {
        return null;
    }
    async evaluateInternal(pageFunction, ...args) {
        return this._doEvaluateInternal(true /* returnByValue */, true /* waitForNavigations */, pageFunction, ...args);
    }
    async evaluateHandleInternal(pageFunction, ...args) {
        return this._doEvaluateInternal(false /* returnByValue */, true /* waitForNavigations */, pageFunction, ...args);
    }
    _createHandle(remoteObject) {
        return new JSHandle(this, remoteObject);
    }
}
exports.ExecutionContext = ExecutionContext;
class JSHandle {
    constructor(context, remoteObject) {
        this._disposed = false;
        this._context = context;
        this._remoteObject = remoteObject;
    }
    async evaluate(pageFunction, arg) {
        return this._context._doEvaluateInternal(true /* returnByValue */, true /* waitForNavigations */, pageFunction, this, arg);
    }
    async evaluateHandle(pageFunction, arg) {
        return this._context._doEvaluateInternal(false /* returnByValue */, true /* waitForNavigations */, pageFunction, this, arg);
    }
    async getProperty(propertyName) {
        const objectHandle = await this.evaluateHandle((object, propertyName) => {
            const result = { __proto__: null };
            result[propertyName] = object[propertyName];
            return result;
        }, propertyName);
        const properties = await objectHandle.getProperties();
        const result = properties.get(propertyName);
        objectHandle.dispose();
        return result;
    }
    getProperties() {
        return this._context._delegate.getProperties(this);
    }
    jsonValue() {
        return this._context._delegate.handleJSONValue(this);
    }
    asElement() {
        return null;
    }
    async dispose() {
        if (this._disposed)
            return;
        this._disposed = true;
        await this._context._delegate.releaseHandle(this);
    }
    toString() {
        return this._context._delegate.handleToString(this, true /* includeType */);
    }
}
exports.JSHandle = JSHandle;
async function prepareFunctionCall(pageFunction, context, args, toCallArgumentIfNeeded) {
    let functionText = pageFunction.toString();
    try {
        new Function('(' + functionText + ')');
    }
    catch (e1) {
        // This means we might have a function shorthand. Try another
        // time prefixing 'function '.
        if (functionText.startsWith('async '))
            functionText = 'async function ' + functionText.substring('async '.length);
        else
            functionText = 'function ' + functionText;
        try {
            new Function('(' + functionText + ')');
        }
        catch (e2) {
            // We tried hard to serialize, but there's a weird beast here.
            throw new Error('Passed function is not well-serializable!');
        }
    }
    const guids = [];
    const handles = [];
    const toDispose = [];
    const pushHandle = (handle) => {
        const guid = helper_1.helper.guid();
        guids.push(guid);
        handles.push(handle);
        return guid;
    };
    const visited = new Set();
    let error;
    const visit = (arg, depth) => {
        if (!depth) {
            error = 'Argument nesting is too deep';
            return;
        }
        if (visited.has(arg)) {
            error = 'Argument is a circular structure';
            return;
        }
        if (Array.isArray(arg)) {
            visited.add(arg);
            const result = [];
            for (let i = 0; i < arg.length; ++i)
                result.push(visit(arg[i], depth - 1));
            visited.delete(arg);
            return result;
        }
        if (arg && (typeof arg === 'object') && !(arg instanceof JSHandle)) {
            visited.add(arg);
            const result = {};
            for (const name of Object.keys(arg))
                result[name] = visit(arg[name], depth - 1);
            visited.delete(arg);
            return result;
        }
        if (arg && (arg instanceof JSHandle)) {
            if (arg._disposed)
                throw new Error('JSHandle is disposed!');
            const adopted = context._adoptIfNeeded(arg);
            if (adopted === null)
                return pushHandle(Promise.resolve(arg));
            toDispose.push(adopted);
            return pushHandle(adopted);
        }
        const { handle, value } = toCallArgumentIfNeeded(arg);
        if (handle)
            return pushHandle(Promise.resolve(handle));
        return value;
    };
    args = args.map(arg => visit(arg, 100));
    if (error)
        throw new Error(error);
    if (!guids.length)
        return { functionText, values: args, handles: [], dispose: () => { } };
    functionText = `(...__playwright__args__) => {
    return (${functionText})(...(() => {
      const args = __playwright__args__;
      __playwright__args__ = undefined;
      const argCount = args[0];
      const handleCount = args[argCount + 1];
      const handles = { __proto__: null };
      for (let i = 0; i < handleCount; i++)
        handles[args[argCount + 2 + i]] = args[argCount + 2 + handleCount + i];
      const visit = (arg) => {
        if ((typeof arg === 'string') && (arg in handles))
          return handles[arg];
        if (arg && (typeof arg === 'object')) {
          for (const name of Object.keys(arg))
            arg[name] = visit(arg[name]);
        }
        return arg;
      };
      const result = [];
      for (let i = 0; i < argCount; i++)
        result[i] = visit(args[i + 1]);
      return result;
    })());
  }`;
    const resolved = await Promise.all(handles);
    const resultHandles = [];
    for (let i = 0; i < resolved.length; i++) {
        const handle = resolved[i];
        if (handle instanceof JSHandle) {
            if (handle._context !== context)
                throw new Error('JSHandles can be evaluated only in the context they were created!');
            resultHandles.push(toCallArgumentIfNeeded(handle).handle);
        }
        else {
            resultHandles.push(handle);
        }
    }
    const dispose = () => {
        toDispose.map(handlePromise => handlePromise.then(handle => handle.dispose()));
    };
    return { functionText, values: [args.length, ...args, guids.length, ...guids], handles: resultHandles, dispose };
}
exports.prepareFunctionCall = prepareFunctionCall;
//# sourceMappingURL=javascript.js.map