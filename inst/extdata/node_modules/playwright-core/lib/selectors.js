"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const selectorEvaluatorSource = require("./generated/selectorEvaluatorSource");
const helper_1 = require("./helper");
const kEvaluatorSymbol = Symbol('evaluator');
class Selectors {
    constructor() {
        this._generation = 0;
        // Note: keep in sync with SelectorEvaluator class.
        this._builtinEngines = new Set([
            'css', 'css:light',
            'xpath', 'xpath:light',
            'text', 'text:light',
            'id', 'id:light',
            'data-testid', 'data-testid:light',
            'data-test-id', 'data-test-id:light',
            'data-test', 'data-test:light'
        ]);
        this._engines = new Map();
    }
    async register(name, script, options = {}) {
        const { contentScript = false } = options;
        if (!name.match(/^[a-zA-Z_0-9-]+$/))
            throw new Error('Selector engine name may only contain [a-zA-Z0-9_] characters');
        // Note: we keep 'zs' for future use.
        if (this._builtinEngines.has(name) || name === 'zs' || name === 'zs:light')
            throw new Error(`"${name}" is a predefined selector engine`);
        const source = await helper_1.helper.evaluationScript(script, undefined, false);
        if (this._engines.has(name))
            throw new Error(`"${name}" selector engine has been already registered`);
        this._engines.set(name, { source, contentScript });
        ++this._generation;
    }
    _needsMainContext(parsed) {
        return parsed.parts.some(({ name }) => {
            const custom = this._engines.get(name);
            return custom ? !custom.contentScript : false;
        });
    }
    async _prepareEvaluator(context) {
        let data = context[kEvaluatorSymbol];
        if (data && data.generation !== this._generation) {
            data.promise.then(handle => handle.dispose());
            data = undefined;
        }
        if (!data) {
            const custom = [];
            for (const [name, { source }] of this._engines)
                custom.push(`{ name: '${name}', engine: (${source}) }`);
            const source = `
        new (${selectorEvaluatorSource.source})([
          ${custom.join(',\n')}
        ])
      `;
            data = {
                promise: context._doEvaluateInternal(false /* returnByValue */, false /* waitForNavigations */, source),
                generation: this._generation
            };
            context[kEvaluatorSymbol] = data;
        }
        return data.promise;
    }
    async _query(frame, selector, scope) {
        const parsed = this._parseSelector(selector);
        const context = this._needsMainContext(parsed) ? await frame._mainContext() : await frame._utilityContext();
        const handle = await context.evaluateHandleInternal(({ evaluator, parsed, scope }) => evaluator.querySelector(parsed, scope || document), { evaluator: await this._prepareEvaluator(context), parsed, scope });
        const elementHandle = handle.asElement();
        if (!elementHandle) {
            handle.dispose();
            return null;
        }
        const mainContext = await frame._mainContext();
        if (elementHandle._context === mainContext)
            return elementHandle;
        const adopted = frame._page._delegate.adoptElementHandle(elementHandle, mainContext);
        elementHandle.dispose();
        return adopted;
    }
    async _queryArray(frame, selector, scope) {
        const parsed = this._parseSelector(selector);
        const context = await frame._mainContext();
        const arrayHandle = await context.evaluateHandleInternal(({ evaluator, parsed, scope }) => evaluator.querySelectorAll(parsed, scope || document), { evaluator: await this._prepareEvaluator(context), parsed, scope });
        return arrayHandle;
    }
    async _queryAll(frame, selector, scope, allowUtilityContext) {
        const parsed = this._parseSelector(selector);
        const context = !allowUtilityContext || this._needsMainContext(parsed) ? await frame._mainContext() : await frame._utilityContext();
        const arrayHandle = await context.evaluateHandleInternal(({ evaluator, parsed, scope }) => evaluator.querySelectorAll(parsed, scope || document), { evaluator: await this._prepareEvaluator(context), parsed, scope });
        const properties = await arrayHandle.getProperties();
        arrayHandle.dispose();
        const result = [];
        for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
                result.push(elementHandle);
            else
                property.dispose();
        }
        return result;
    }
    _waitForSelectorTask(selector, waitFor, deadline) {
        const parsed = this._parseSelector(selector);
        const task = async (context) => context.evaluateHandleInternal(({ evaluator, parsed, waitFor, timeout }) => {
            return evaluator.injected.poll('raf', timeout, () => {
                const element = evaluator.querySelector(parsed, document);
                switch (waitFor) {
                    case 'attached':
                        return element || false;
                    case 'detached':
                        return !element;
                    case 'visible':
                        return element && evaluator.injected.isVisible(element) ? element : false;
                    case 'hidden':
                        return !element || !evaluator.injected.isVisible(element);
                }
            });
        }, { evaluator: await this._prepareEvaluator(context), parsed, waitFor, timeout: helper_1.helper.timeUntilDeadline(deadline) });
        return { world: this._needsMainContext(parsed) ? 'main' : 'utility', task };
    }
    _dispatchEventTask(selector, type, eventInit, deadline) {
        const parsed = this._parseSelector(selector);
        const task = async (context) => context.evaluateHandleInternal(({ evaluator, parsed, type, eventInit, timeout }) => {
            return evaluator.injected.poll('raf', timeout, () => {
                const element = evaluator.querySelector(parsed, document);
                if (element)
                    evaluator.injected.dispatchEvent(element, type, eventInit);
                return element || false;
            });
        }, { evaluator: await this._prepareEvaluator(context), parsed, type, eventInit, timeout: helper_1.helper.timeUntilDeadline(deadline) });
        return task;
    }
    async _createSelector(name, handle) {
        const mainContext = await handle._page.mainFrame()._mainContext();
        return mainContext.evaluateInternal(({ evaluator, target, name }) => {
            return evaluator.engines.get(name).create(document.documentElement, target);
        }, { evaluator: await this._prepareEvaluator(mainContext), target: handle, name });
    }
    _parseSelector(selector) {
        helper_1.assert(helper_1.helper.isString(selector), `selector must be a string`);
        let index = 0;
        let quote;
        let start = 0;
        const result = { parts: [] };
        const append = () => {
            const part = selector.substring(start, index).trim();
            const eqIndex = part.indexOf('=');
            let name;
            let body;
            if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
                name = part.substring(0, eqIndex).trim();
                body = part.substring(eqIndex + 1);
            }
            else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
                name = 'text';
                body = part;
            }
            else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
                name = 'text';
                body = part;
            }
            else if (/^\(*\/\//.test(part)) {
                // If selector starts with '//' or '//' prefixed with multiple opening
                // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817
                name = 'xpath';
                body = part;
            }
            else {
                name = 'css';
                body = part;
            }
            name = name.toLowerCase();
            let capture = false;
            if (name[0] === '*') {
                capture = true;
                name = name.substring(1);
            }
            if (!this._builtinEngines.has(name) && !this._engines.has(name))
                throw new Error(`Unknown engine "${name}" while parsing selector ${selector}`);
            result.parts.push({ name, body });
            if (capture) {
                if (result.capture !== undefined)
                    throw new Error(`Only one of the selectors can capture using * modifier`);
                result.capture = result.parts.length - 1;
            }
        };
        while (index < selector.length) {
            const c = selector[index];
            if (c === '\\' && index + 1 < selector.length) {
                index += 2;
            }
            else if (c === quote) {
                quote = undefined;
                index++;
            }
            else if (!quote && c === '>' && selector[index + 1] === '>') {
                append();
                index += 2;
                start = index;
            }
            else {
                index++;
            }
        }
        append();
        return result;
    }
}
exports.Selectors = Selectors;
exports.selectors = new Selectors();
//# sourceMappingURL=selectors.js.map