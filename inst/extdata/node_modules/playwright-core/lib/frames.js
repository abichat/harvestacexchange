"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const util = require("util");
const dom = require("./dom");
const errors_1 = require("./errors");
const events_1 = require("./events");
const helper_1 = require("./helper");
const selectors_1 = require("./selectors");
const types = require("./types");
const hints_1 = require("./hints");
class FrameManager {
    constructor(page) {
        this._frames = new Map();
        this._consoleMessageTags = new Map();
        this._signalBarriers = new Set();
        this._page = page;
        this._mainFrame = undefined;
    }
    mainFrame() {
        return this._mainFrame;
    }
    frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
            frames.push(frame);
            for (const subframe of frame.childFrames())
                collect(subframe);
        }
    }
    frame(frameId) {
        return this._frames.get(frameId) || null;
    }
    frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
            if (this._mainFrame) {
                // Update frame id to retain frame identity on cross-process navigation.
                this._frames.delete(this._mainFrame._id);
                this._mainFrame._id = frameId;
            }
            else {
                helper_1.assert(!this._frames.has(frameId));
                this._mainFrame = new Frame(this._page, frameId, parentFrame);
            }
            this._frames.set(frameId, this._mainFrame);
            return this._mainFrame;
        }
        else {
            helper_1.assert(!this._frames.has(frameId));
            const frame = new Frame(this._page, frameId, parentFrame);
            this._frames.set(frameId, frame);
            this._page.emit(events_1.Events.Page.FrameAttached, frame);
            return frame;
        }
    }
    async waitForSignalsCreatedBy(action, deadline, options = {}, input) {
        if (options.noWaitAfter)
            return action();
        const barrier = new SignalBarrier(options, deadline);
        this._signalBarriers.add(barrier);
        try {
            const result = await action();
            if (input)
                await this._page._delegate.inputActionEpilogue();
            await barrier.waitFor();
            // Resolve in the next task, after all waitForNavigations.
            await new Promise(helper_1.helper.makeWaitForNextTask());
            return result;
        }
        finally {
            this._signalBarriers.delete(barrier);
        }
    }
    frameWillPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
            barrier.retain();
    }
    frameDidPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
            barrier.release();
    }
    frameRequestedNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        for (const barrier of this._signalBarriers)
            barrier.addFrameNavigation(frame);
        frame._pendingDocumentId = documentId;
    }
    frameUpdatedDocumentIdForNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._pendingDocumentId = documentId;
    }
    frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        this.removeChildFramesRecursively(frame);
        frame._url = url;
        frame._name = name;
        helper_1.assert(!frame._pendingDocumentId || frame._pendingDocumentId === documentId);
        frame._lastDocumentId = documentId;
        frame._pendingDocumentId = '';
        for (const task of frame._frameTasks)
            task.onNewDocument(documentId);
        this.clearFrameLifecycle(frame);
        if (!initial)
            this._page.emit(events_1.Events.Page.FrameNavigated, frame);
    }
    frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._url = url;
        for (const task of frame._frameTasks)
            task.onSameDocument();
        this._page.emit(events_1.Events.Page.FrameNavigated, frame);
    }
    frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
            this._removeFramesRecursively(frame);
    }
    frameStoppedLoading(frameId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        const hasDOMContentLoaded = frame._firedLifecycleEvents.has('domcontentloaded');
        const hasLoad = frame._firedLifecycleEvents.has('load');
        frame._firedLifecycleEvents.add('domcontentloaded');
        frame._firedLifecycleEvents.add('load');
        this._notifyLifecycle(frame);
        if (frame === this.mainFrame() && !hasDOMContentLoaded)
            this._page.emit(events_1.Events.Page.DOMContentLoaded);
        if (frame === this.mainFrame() && !hasLoad)
            this._page.emit(events_1.Events.Page.Load);
    }
    frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._firedLifecycleEvents.add(event);
        this._notifyLifecycle(frame);
        if (frame === this._mainFrame && event === 'load')
            this._page.emit(events_1.Events.Page.Load);
        if (frame === this._mainFrame && event === 'domcontentloaded')
            this._page.emit(events_1.Events.Page.DOMContentLoaded);
    }
    clearFrameLifecycle(frame) {
        frame._firedLifecycleEvents.clear();
        // Keep the current navigation request if any.
        frame._inflightRequests = new Set(Array.from(frame._inflightRequests).filter(request => request._documentId === frame._lastDocumentId));
        frame._stopNetworkIdleTimer();
        if (frame._inflightRequests.size === 0)
            frame._startNetworkIdleTimer();
    }
    requestStarted(request) {
        this._inflightRequestStarted(request);
        for (const task of request.frame()._frameTasks)
            task.onRequest(request);
        if (!request._isFavicon)
            this._page._requestStarted(request);
    }
    requestReceivedResponse(response) {
        if (!response.request()._isFavicon)
            this._page.emit(events_1.Events.Page.Response, response);
    }
    requestFinished(request) {
        this._inflightRequestFinished(request);
        if (!request._isFavicon)
            this._page.emit(events_1.Events.Page.RequestFinished, request);
    }
    requestFailed(request, canceled) {
        this._inflightRequestFinished(request);
        if (request._documentId) {
            const isPendingDocument = request.frame()._pendingDocumentId === request._documentId;
            if (isPendingDocument) {
                request.frame()._pendingDocumentId = '';
                let errorText = request.failure().errorText;
                if (canceled)
                    errorText += '; maybe frame was detached?';
                for (const task of request.frame()._frameTasks)
                    task.onNewDocument(request._documentId, new Error(errorText));
            }
        }
        if (!request._isFavicon)
            this._page.emit(events_1.Events.Page.RequestFailed, request);
    }
    provisionalLoadFailed(frame, documentId, error) {
        for (const task of frame._frameTasks)
            task.onNewDocument(documentId, new Error(error));
    }
    _notifyLifecycle(frame) {
        for (let parent = frame; parent; parent = parent.parentFrame()) {
            for (const frameTask of parent._frameTasks)
                frameTask.onLifecycle();
        }
    }
    removeChildFramesRecursively(frame) {
        for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
    }
    _removeFramesRecursively(frame) {
        this.removeChildFramesRecursively(frame);
        frame._onDetached();
        this._frames.delete(frame._id);
        this._page.emit(events_1.Events.Page.FrameDetached, frame);
    }
    _inflightRequestFinished(request) {
        const frame = request.frame();
        if (request._isFavicon)
            return;
        if (!frame._inflightRequests.has(request))
            return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
            frame._startNetworkIdleTimer();
    }
    _inflightRequestStarted(request) {
        const frame = request.frame();
        if (request._isFavicon)
            return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
            frame._stopNetworkIdleTimer();
    }
    interceptConsoleMessage(message) {
        if (message.type() !== 'debug')
            return false;
        const tag = message.text();
        const handler = this._consoleMessageTags.get(tag);
        if (!handler)
            return false;
        this._consoleMessageTags.delete(tag);
        handler();
        return true;
    }
}
exports.FrameManager = FrameManager;
class Frame {
    constructor(page, id, parentFrame) {
        this._lastDocumentId = '';
        this._pendingDocumentId = '';
        this._frameTasks = new Set();
        this._url = '';
        this._detached = false;
        this._contextData = new Map();
        this._childFrames = new Set();
        this._name = '';
        this._inflightRequests = new Set();
        this._setContentCounter = 0;
        this._detachedCallback = () => { };
        this._id = id;
        this._firedLifecycleEvents = new Set();
        this._page = page;
        this._parentFrame = parentFrame;
        this._detachedPromise = new Promise(x => this._detachedCallback = x);
        this._contextData.set('main', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._contextData.set('utility', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._setContext('main', null);
        this._setContext('utility', null);
        if (this._parentFrame)
            this._parentFrame._childFrames.add(this);
    }
    async goto(url, options = {}) {
        const headers = (this._page._state.extraHTTPHeaders || {});
        let referer = headers['referer'] || headers['Referer'];
        if (options.referer !== undefined) {
            if (referer !== undefined && referer !== options.referer)
                throw new Error('"referer" is already specified as extra HTTP header');
            referer = options.referer;
        }
        url = helper_1.helper.completeUserURL(url);
        const frameTask = new FrameTask(this, options, url);
        const sameDocumentPromise = frameTask.waitForSameDocumentNavigation();
        const navigateResult = await frameTask.raceAgainstFailures(this._page._delegate.navigateFrame(this, url, referer)).catch(e => {
            // Do not leave sameDocumentPromise unhandled.
            sameDocumentPromise.catch(e => { });
            throw e;
        });
        if (navigateResult.newDocumentId) {
            // Do not leave sameDocumentPromise unhandled.
            sameDocumentPromise.catch(e => { });
            await frameTask.waitForSpecificDocument(navigateResult.newDocumentId);
        }
        else {
            await sameDocumentPromise;
        }
        const request = (navigateResult && navigateResult.newDocumentId) ? frameTask.request(navigateResult.newDocumentId) : null;
        await frameTask.waitForLifecycle(options.waitUntil === undefined ? 'load' : options.waitUntil);
        frameTask.done();
        return request ? request._finalRequest().response() : null;
    }
    async waitForNavigation(options = {}) {
        return this._waitForNavigation(options);
    }
    async _waitForNavigation(options = {}) {
        const frameTask = new FrameTask(this, options);
        let documentId;
        await Promise.race([
            frameTask.waitForNewDocument(options.url).then(id => documentId = id),
            frameTask.waitForSameDocumentNavigation(options.url),
        ]);
        const request = documentId ? frameTask.request(documentId) : null;
        if (options.waitUntil !== 'commit')
            await frameTask.waitForLifecycle(options.waitUntil === undefined ? 'load' : options.waitUntil);
        frameTask.done();
        return request ? request._finalRequest().response() : null;
    }
    async waitForLoadState(state = 'load', options = {}) {
        const frameTask = new FrameTask(this, options);
        await frameTask.waitForLifecycle(state);
        frameTask.done();
    }
    async frameElement() {
        return this._page._delegate.getFrameElement(this);
    }
    _context(contextType) {
        if (this._detached)
            throw new Error(`Execution Context is not available in detached frame "${this.url()}" (are you trying to evaluate?)`);
        return this._contextData.get(contextType).contextPromise;
    }
    _mainContext() {
        return this._context('main');
    }
    _utilityContext() {
        return this._context('utility');
    }
    async evaluateHandle(pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 2);
        const context = await this._mainContext();
        return context.evaluateHandleInternal(pageFunction, arg);
    }
    async evaluate(pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 2);
        const context = await this._mainContext();
        return context.evaluateInternal(pageFunction, arg);
    }
    async $(selector) {
        return selectors_1.selectors._query(this, selector);
    }
    async waitForSelector(selector, options) {
        if (options && options.visibility)
            throw new Error('options.visibility is not supported, did you mean options.waitFor?');
        const { waitFor = 'attached' } = (options || {});
        if (!['attached', 'detached', 'visible', 'hidden'].includes(waitFor))
            throw new Error(`Unsupported waitFor option "${waitFor}"`);
        const deadline = this._page._timeoutSettings.computeDeadline(options);
        const { world, task } = selectors_1.selectors._waitForSelectorTask(selector, waitFor, deadline);
        const result = await this._scheduleRerunnableTask(task, world, deadline, `selector "${selectorToString(selector, waitFor)}"`);
        if (!result.asElement()) {
            result.dispose();
            return null;
        }
        const handle = result.asElement();
        const mainContext = await this._mainContext();
        if (handle && handle._context !== mainContext) {
            const adopted = await this._page._delegate.adoptElementHandle(handle, mainContext);
            handle.dispose();
            return adopted;
        }
        return handle;
    }
    async dispatchEvent(selector, type, eventInit, options) {
        const deadline = this._page._timeoutSettings.computeDeadline(options);
        const task = selectors_1.selectors._dispatchEventTask(selector, type, eventInit || {}, deadline);
        const result = await this._scheduleRerunnableTask(task, 'main', deadline, `selector "${selectorToString(selector, 'attached')}"`);
        result.dispose();
    }
    async $eval(selector, pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 3);
        const handle = await this.$(selector);
        if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await handle.evaluate(pageFunction, arg);
        handle.dispose();
        return result;
    }
    async $$eval(selector, pageFunction, arg) {
        helper_1.assertMaxArguments(arguments.length, 3);
        const arrayHandle = await selectors_1.selectors._queryArray(this, selector);
        const result = await arrayHandle.evaluate(pageFunction, arg);
        arrayHandle.dispose();
        return result;
    }
    async $$(selector) {
        return selectors_1.selectors._queryAll(this, selector);
    }
    async content() {
        const context = await this._utilityContext();
        return context.evaluateInternal(() => {
            let retVal = '';
            if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
            if (document.documentElement)
                retVal += document.documentElement.outerHTML;
            return retVal;
        });
    }
    async setContent(html, options) {
        const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
        const context = await this._utilityContext();
        const lifecyclePromise = new Promise((resolve, reject) => {
            this._page._frameManager._consoleMessageTags.set(tag, () => {
                // Clear lifecycle right after document.open() - see 'tag' below.
                this._page._frameManager.clearFrameLifecycle(this);
                this.waitForLoadState(options ? options.waitUntil : 'load', options).then(resolve).catch(reject);
            });
        });
        const contentPromise = context.evaluateInternal(({ html, tag }) => {
            window.stop();
            document.open();
            console.debug(tag); // eslint-disable-line no-console
            document.write(html);
            document.close();
        }, { html, tag });
        await Promise.all([contentPromise, lifecyclePromise]);
    }
    name() {
        return this._name || '';
    }
    url() {
        return this._url;
    }
    parentFrame() {
        return this._parentFrame;
    }
    childFrames() {
        return Array.from(this._childFrames);
    }
    isDetached() {
        return this._detached;
    }
    async addScriptTag(options) {
        const { url = null, path = null, content = null, type = '' } = options;
        if (!url && !path && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandleInternal(addScriptUrl, { url, type })).asElement();
            let result;
            if (path !== null) {
                let contents = await util.promisify(fs.readFile)(path, 'utf8');
                contents += '//# sourceURL=' + path.replace(/\n/g, '');
                result = (await context.evaluateHandleInternal(addScriptContent, { content: contents, type })).asElement();
            }
            else {
                result = (await context.evaluateHandleInternal(addScriptContent, { content: content, type })).asElement();
            }
            // Another round trip to the browser to ensure that we receive CSP error messages
            // (if any) logged asynchronously in a separate task on the content main thread.
            if (this._page._delegate.cspErrorsAsynchronousForInlineScipts)
                await context.evaluateInternal(() => true);
            return result;
        });
        async function addScriptUrl(options) {
            const script = document.createElement('script');
            script.src = options.url;
            if (options.type)
                script.type = options.type;
            const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = e => rej(typeof e === 'string' ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
            });
            document.head.appendChild(script);
            await promise;
            return script;
        }
        function addScriptContent(options) {
            const script = document.createElement('script');
            script.type = options.type || 'text/javascript';
            script.text = options.content;
            let error = null;
            script.onerror = e => error = e;
            document.head.appendChild(script);
            if (error)
                throw error;
            return script;
        }
    }
    async addStyleTag(options) {
        const { url = null, path = null, content = null } = options;
        if (!url && !path && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandleInternal(addStyleUrl, url)).asElement();
            if (path !== null) {
                let contents = await util.promisify(fs.readFile)(path, 'utf8');
                contents += '/*# sourceURL=' + path.replace(/\n/g, '') + '*/';
                return (await context.evaluateHandleInternal(addStyleContent, contents)).asElement();
            }
            return (await context.evaluateHandleInternal(addStyleContent, content)).asElement();
        });
        async function addStyleUrl(url) {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
            });
            document.head.appendChild(link);
            await promise;
            return link;
        }
        async function addStyleContent(content) {
            const style = document.createElement('style');
            style.type = 'text/css';
            style.appendChild(document.createTextNode(content));
            const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
            });
            document.head.appendChild(style);
            await promise;
            return style;
        }
    }
    async _raceWithCSPError(func) {
        const listeners = [];
        let result;
        let error;
        let cspMessage;
        const actionPromise = new Promise(async (resolve) => {
            try {
                result = await func();
            }
            catch (e) {
                error = e;
            }
            resolve();
        });
        const errorPromise = new Promise(resolve => {
            listeners.push(helper_1.helper.addEventListener(this._page, events_1.Events.Page.Console, (message) => {
                if (message.type() === 'error' && message.text().includes('Content Security Policy')) {
                    cspMessage = message;
                    resolve();
                }
            }));
        });
        await Promise.race([actionPromise, errorPromise]);
        helper_1.helper.removeEventListeners(listeners);
        if (cspMessage)
            throw new Error(cspMessage.text());
        if (error)
            throw error;
        return result;
    }
    async _retryWithSelectorIfNotConnected(selector, options, action) {
        const deadline = this._page._timeoutSettings.computeDeadline(options);
        while (!helper_1.helper.isPastDeadline(deadline)) {
            try {
                const { world, task } = selectors_1.selectors._waitForSelectorTask(selector, 'attached', deadline);
                const handle = await this._scheduleRerunnableTask(task, world, deadline, `selector "${selector}"`);
                const element = handle.asElement();
                try {
                    return await action(element, deadline);
                }
                finally {
                    element.dispose();
                }
            }
            catch (e) {
                if (!(e instanceof errors_1.NotConnectedError))
                    throw e;
                this._page._log(dom.inputLog, 'Element was detached from the DOM, retrying');
            }
        }
        throw new errors_1.TimeoutError(`waiting for selector "${selector}" failed: timeout exceeded`);
    }
    async click(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.click(helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async dblclick(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.dblclick(helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async fill(selector, value, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.fill(value, helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async focus(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.focus());
    }
    async hover(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.hover(helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async selectOption(selector, values, options = {}) {
        return await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.selectOption(values, helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async setInputFiles(selector, files, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.setInputFiles(files, helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async type(selector, text, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.type(text, helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async press(selector, key, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.press(key, helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async check(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.check(helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async uncheck(selector, options = {}) {
        await this._retryWithSelectorIfNotConnected(selector, options, (handle, deadline) => handle.uncheck(helper_1.helper.optionsWithUpdatedTimeout(options, deadline)));
    }
    async waitForTimeout(timeout) {
        hints_1.waitForTimeoutWasUsed(this._page);
        await new Promise(fulfill => setTimeout(fulfill, timeout));
    }
    async waitForFunction(pageFunction, arg, options = {}) {
        const { polling = 'raf' } = options;
        const deadline = this._page._timeoutSettings.computeDeadline(options);
        if (helper_1.helper.isString(polling))
            helper_1.assert(polling === 'raf', 'Unknown polling option: ' + polling);
        else if (helper_1.helper.isNumber(polling))
            helper_1.assert(polling > 0, 'Cannot poll with non-positive interval: ' + polling);
        else
            throw new Error('Unknown polling options: ' + polling);
        const predicateBody = helper_1.helper.isString(pageFunction) ? 'return (' + pageFunction + ')' : 'return (' + pageFunction + ')(arg)';
        const task = async (context) => context.evaluateHandleInternal(({ injected, predicateBody, polling, timeout, arg }) => {
            const innerPredicate = new Function('arg', predicateBody);
            return injected.poll(polling, timeout, () => innerPredicate(arg));
        }, { injected: await context._injected(), predicateBody, polling, timeout: helper_1.helper.timeUntilDeadline(deadline), arg });
        return this._scheduleRerunnableTask(task, 'main', deadline);
    }
    async title() {
        const context = await this._utilityContext();
        return context.evaluateInternal(() => document.title);
    }
    _onDetached() {
        this._detached = true;
        this._detachedCallback();
        for (const data of this._contextData.values()) {
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.terminate(new Error('waitForFunction failed: frame got detached.'));
        }
        if (this._parentFrame)
            this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
    }
    _scheduleRerunnableTask(task, contextType, deadline, title) {
        const data = this._contextData.get(contextType);
        const rerunnableTask = new RerunnableTask(data, task, deadline, title);
        data.rerunnableTasks.add(rerunnableTask);
        if (data.context)
            rerunnableTask.rerun(data.context);
        return rerunnableTask.promise;
    }
    _setContext(contextType, context) {
        const data = this._contextData.get(contextType);
        data.context = context;
        if (context) {
            data.contextResolveCallback.call(null, context);
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.rerun(context);
        }
        else {
            data.contextPromise = new Promise(fulfill => {
                data.contextResolveCallback = fulfill;
            });
        }
    }
    _contextCreated(contextType, context) {
        const data = this._contextData.get(contextType);
        // In case of multiple sessions to the same target, there's a race between
        // connections so we might end up creating multiple isolated worlds.
        // We can use either.
        if (data.context)
            this._setContext(contextType, null);
        this._setContext(contextType, context);
    }
    _contextDestroyed(context) {
        for (const [contextType, data] of this._contextData) {
            if (data.context === context)
                this._setContext(contextType, null);
        }
    }
    _startNetworkIdleTimer() {
        helper_1.assert(!this._networkIdleTimer);
        if (this._firedLifecycleEvents.has('networkidle'))
            return;
        this._networkIdleTimer = setTimeout(() => { this._page._frameManager.frameLifecycleEvent(this._id, 'networkidle'); }, 500);
    }
    _stopNetworkIdleTimer() {
        if (this._networkIdleTimer)
            clearTimeout(this._networkIdleTimer);
        this._networkIdleTimer = undefined;
    }
}
exports.Frame = Frame;
class RerunnableTask {
    constructor(data, task, deadline, title) {
        this._resolve = () => { };
        this._reject = () => { };
        this._terminated = false;
        this._contextData = data;
        this._task = task;
        this._runCount = 0;
        this.promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        // Since page navigation requires us to re-install the pageScript, we should track
        // timeout on our end.
        const timeoutError = new errors_1.TimeoutError(`waiting for ${title || 'function'} failed: timeout exceeded`);
        this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), helper_1.helper.timeUntilDeadline(deadline));
    }
    terminate(error) {
        this._terminated = true;
        this._reject(error);
        this._doCleanup();
    }
    async rerun(context) {
        const runCount = ++this._runCount;
        let success = null;
        let error = null;
        try {
            success = await this._task(context);
        }
        catch (e) {
            error = e;
        }
        if (this._terminated || runCount !== this._runCount) {
            if (success)
                success.dispose();
            return;
        }
        // Ignore timeouts in pageScript - we track timeouts ourselves.
        // If execution context has been already destroyed, `context.evaluate` will
        // throw an error - ignore this predicate run altogether.
        if (!error && await context.evaluateInternal(s => !s, success).catch(e => true)) {
            success.dispose();
            return;
        }
        // When the page is navigated, the promise is rejected.
        // We will try again in the new execution context.
        if (error && error.message.includes('Execution context was destroyed'))
            return;
        // We could have tried to evaluate in a context which was already
        // destroyed.
        if (error && error.message.includes('Cannot find context with specified id'))
            return;
        if (error)
            this._reject(error);
        else
            this._resolve(success);
        this._doCleanup();
    }
    _doCleanup() {
        if (this._timeoutTimer)
            clearTimeout(this._timeoutTimer);
        this._contextData.rerunnableTasks.delete(this);
    }
}
function selectorToString(selector, waitFor) {
    let label;
    switch (waitFor) {
        case 'visible':
            label = '[visible] ';
            break;
        case 'hidden':
            label = '[hidden] ';
            break;
        case 'attached':
            label = '';
            break;
        case 'detached':
            label = '[detached]';
            break;
    }
    return `${label}${selector}`;
}
class SignalBarrier {
    constructor(options, deadline) {
        this._frameIds = new Map();
        this._protectCount = 0;
        this._expectedPopups = 0;
        this._promiseCallback = () => { };
        this._options = options;
        this._deadline = deadline;
        this._promise = new Promise(f => this._promiseCallback = f);
        this.retain();
    }
    waitFor() {
        this.release();
        return this._promise;
    }
    async addFrameNavigation(frame) {
        this.retain();
        const options = helper_1.helper.optionsWithUpdatedTimeout(this._options, this._deadline);
        await frame._waitForNavigation({ ...options, waitUntil: 'commit' }).catch(e => { });
        this.release();
    }
    async expectPopup() {
        ++this._expectedPopups;
    }
    async unexpectPopup() {
        --this._expectedPopups;
        this._maybeResolve();
    }
    async addPopup(pageOrError) {
        if (this._expectedPopups)
            --this._expectedPopups;
        this.retain();
        await pageOrError;
        this.release();
    }
    retain() {
        ++this._protectCount;
    }
    release() {
        --this._protectCount;
        this._maybeResolve();
    }
    async _maybeResolve() {
        if (!this._protectCount && !this._expectedPopups && !this._frameIds.size)
            this._promiseCallback();
    }
}
exports.SignalBarrier = SignalBarrier;
class FrameTask {
    constructor(frame, options, url) {
        this._requestMap = new Map();
        this.onNewDocument = () => { };
        this.onSameDocument = () => { };
        this.onLifecycle = () => { };
        this._frame = frame;
        this._url = url;
        // Process timeouts
        let timeoutPromise = new Promise(() => { });
        const { timeout = frame._page._timeoutSettings.navigationTimeout() } = options;
        if (timeout) {
            const errorMessage = 'Navigation timeout exceeded';
            timeoutPromise = new Promise(fulfill => this._timer = setTimeout(fulfill, timeout))
                .then(() => { throw new errors_1.TimeoutError(errorMessage); });
        }
        // Process detached frames
        this._failurePromise = Promise.race([
            timeoutPromise,
            this._frame._page._disconnectedPromise.then(() => { throw new Error('Navigation failed because browser has disconnected!'); }),
            this._frame._detachedPromise.then(() => { throw new Error('Navigating frame was detached!'); }),
        ]);
        frame._frameTasks.add(this);
    }
    onRequest(request) {
        if (!request._documentId || request.redirectedFrom())
            return;
        this._requestMap.set(request._documentId, request);
    }
    async raceAgainstFailures(promise) {
        let result;
        let error;
        await Promise.race([
            this._failurePromise.catch(e => error = e),
            promise.then(r => result = r).catch(e => error = e)
        ]);
        if (!error)
            return result;
        this.done();
        if (this._url)
            error.message = error.message + ` while navigating to ${this._url}`;
        throw error;
    }
    request(documentId) {
        return this._requestMap.get(documentId);
    }
    waitForSameDocumentNavigation(url) {
        return this.raceAgainstFailures(new Promise((resolve, reject) => {
            this.onSameDocument = () => {
                if (helper_1.helper.urlMatches(this._frame.url(), url))
                    resolve();
            };
        }));
    }
    waitForSpecificDocument(expectedDocumentId) {
        return this.raceAgainstFailures(new Promise((resolve, reject) => {
            this.onNewDocument = (documentId, error) => {
                if (documentId === expectedDocumentId) {
                    if (!error)
                        resolve();
                    else
                        reject(error);
                }
                else if (!error) {
                    reject(new Error('Navigation interrupted by another one'));
                }
            };
        }));
    }
    waitForNewDocument(url) {
        return this.raceAgainstFailures(new Promise((resolve, reject) => {
            this.onNewDocument = (documentId, error) => {
                if (!error && !helper_1.helper.urlMatches(this._frame.url(), url))
                    return;
                if (error)
                    reject(error);
                else
                    resolve(documentId);
            };
        }));
    }
    waitForLifecycle(waitUntil) {
        if (waitUntil === 'networkidle0')
            waitUntil = 'networkidle';
        if (!types.kLifecycleEvents.has(waitUntil))
            throw new Error(`Unsupported waitUntil option ${String(waitUntil)}`);
        return this.raceAgainstFailures(new Promise((resolve, reject) => {
            this.onLifecycle = () => {
                if (!checkLifecycleRecursively(this._frame))
                    return;
                resolve();
            };
            this.onLifecycle();
        }));
        function checkLifecycleRecursively(frame) {
            if (!frame._firedLifecycleEvents.has(waitUntil))
                return false;
            for (const child of frame.childFrames()) {
                if (!checkLifecycleRecursively(child))
                    return false;
            }
            return true;
        }
    }
    done() {
        this._frame._frameTasks.delete(this);
        if (this._timer)
            clearTimeout(this._timer);
        this._failurePromise.catch(e => { });
    }
}
exports.FrameTask = FrameTask;
//# sourceMappingURL=frames.js.map