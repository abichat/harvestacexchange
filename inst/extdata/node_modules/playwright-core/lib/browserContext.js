"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("./helper");
const network = require("./network");
const timeoutSettings_1 = require("./timeoutSettings");
const events_1 = require("./events");
const extendedEventEmitter_1 = require("./extendedEventEmitter");
const logger_1 = require("./logger");
class BrowserContextBase extends extendedEventEmitter_1.ExtendedEventEmitter {
    constructor(browserBase, options) {
        super();
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._pageBindings = new Map();
        this._routes = [];
        this._closed = false;
        this._permissions = new Map();
        this._downloads = new Set();
        this._browserBase = browserBase;
        this._options = options;
        this._logger = options.logger ? new logger_1.RootLogger(options.logger) : browserBase;
        this._closePromise = new Promise(fulfill => this._closePromiseFulfill = fulfill);
    }
    _abortPromiseForEvent(event) {
        return event === events_1.Events.BrowserContext.Close ? super._abortPromiseForEvent(event) : this._closePromise;
    }
    _computeDeadline(options) {
        return this._timeoutSettings.computeDeadline(options);
    }
    _browserClosed() {
        for (const page of this.pages())
            page._didClose();
        this._didCloseInternal(true);
    }
    async _didCloseInternal(omitDeleteDownloads = false) {
        this._closed = true;
        this.emit(events_1.Events.BrowserContext.Close);
        this._closePromiseFulfill(new Error('Context closed'));
        if (!omitDeleteDownloads)
            await Promise.all([...this._downloads].map(d => d.delete()));
        this._downloads.clear();
    }
    async grantPermissions(permissions, options) {
        let origin = '*';
        if (options && options.origin) {
            const url = new URL(options.origin);
            origin = url.origin;
        }
        const existing = new Set(this._permissions.get(origin) || []);
        permissions.forEach(p => existing.add(p));
        const list = [...existing.values()];
        this._permissions.set(origin, list);
        await this._doGrantPermissions(origin, list);
    }
    async clearPermissions() {
        this._permissions.clear();
        await this._doClearPermissions();
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    _isLogEnabled(log) {
        return this._logger._isLogEnabled(log);
    }
    _log(log, message, ...args) {
        return this._logger._log(log, message, ...args);
    }
}
exports.BrowserContextBase = BrowserContextBase;
function assertBrowserContextIsNotOwned(context) {
    for (const page of context.pages()) {
        if (page._ownedContext)
            throw new Error('Please use browser.newContext() for multi-page scripts that share the context.');
    }
}
exports.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
function validateBrowserContextOptions(options) {
    const result = { ...options };
    if (!result.viewport && result.viewport !== null)
        result.viewport = { width: 1280, height: 720 };
    if (result.viewport)
        result.viewport = { ...result.viewport };
    if (result.geolocation)
        result.geolocation = verifyGeolocation(result.geolocation);
    if (result.extraHTTPHeaders)
        result.extraHTTPHeaders = network.verifyHeaders(result.extraHTTPHeaders);
    return result;
}
exports.validateBrowserContextOptions = validateBrowserContextOptions;
function verifyGeolocation(geolocation) {
    const result = { ...geolocation };
    result.accuracy = result.accuracy || 0;
    const { longitude, latitude, accuracy } = result;
    if (!helper_1.helper.isNumber(longitude) || longitude < -180 || longitude > 180)
        throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
    if (!helper_1.helper.isNumber(latitude) || latitude < -90 || latitude > 90)
        throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
    if (!helper_1.helper.isNumber(accuracy) || accuracy < 0)
        throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
    return result;
}
exports.verifyGeolocation = verifyGeolocation;
//# sourceMappingURL=browserContext.js.map