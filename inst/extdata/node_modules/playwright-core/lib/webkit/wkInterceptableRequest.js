"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("../helper");
const network = require("../network");
const logger_1 = require("../logger");
const errorReasons = {
    'aborted': 'Cancellation',
    'accessdenied': 'AccessControl',
    'addressunreachable': 'General',
    'blockedbyclient': 'Cancellation',
    'blockedbyresponse': 'General',
    'connectionaborted': 'General',
    'connectionclosed': 'General',
    'connectionfailed': 'General',
    'connectionrefused': 'General',
    'connectionreset': 'General',
    'internetdisconnected': 'General',
    'namenotresolved': 'General',
    'timedout': 'Timeout',
    'failed': 'General',
};
class WKInterceptableRequest {
    constructor(session, allowInterception, frame, event, redirectedFrom, documentId) {
        this._interceptedCallback = () => { };
        this._session = session;
        this._requestId = event.requestId;
        const resourceType = event.type ? event.type.toLowerCase() : (redirectedFrom ? redirectedFrom.resourceType() : 'unknown');
        this.request = new network.Request(allowInterception ? this : null, frame, redirectedFrom, documentId, event.request.url, resourceType, event.request.method, event.request.postData || null, headersObject(event.request.headers));
        this._interceptedPromise = new Promise(f => this._interceptedCallback = f);
    }
    async abort(errorCode) {
        const reason = errorReasons[errorCode];
        helper_1.assert(reason, 'Unknown error code: ' + errorCode);
        await this._interceptedPromise;
        await this._session.send('Network.interceptAsError', { requestId: this._requestId, reason }).catch(error => {
            // In certain cases, protocol will return error if the request was already canceled
            // or the page was closed. We should tolerate these errors.
            logger_1.logError(this.request._page);
        });
    }
    async fulfill(response) {
        await this._interceptedPromise;
        const base64Encoded = !!response.body && !helper_1.helper.isString(response.body);
        const responseBody = response.body ? (base64Encoded ? response.body.toString('base64') : response.body) : '';
        const responseHeaders = {};
        if (response.headers) {
            for (const header of Object.keys(response.headers))
                responseHeaders[header.toLowerCase()] = String(response.headers[header]);
        }
        if (response.contentType)
            responseHeaders['content-type'] = response.contentType;
        if (responseBody && !('content-length' in responseHeaders))
            responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));
        await this._session.send('Network.interceptWithResponse', {
            requestId: this._requestId,
            status: response.status || 200,
            statusText: network.STATUS_TEXTS[String(response.status || 200)],
            mimeType: response.contentType || (base64Encoded ? 'application/octet-stream' : 'text/plain'),
            headers: responseHeaders,
            base64Encoded,
            content: responseBody
        }).catch(error => {
            // In certain cases, protocol will return error if the request was already canceled
            // or the page was closed. We should tolerate these errors.
            logger_1.logError(this.request._page);
        });
    }
    async continue(overrides) {
        await this._interceptedPromise;
        await this._session.send('Network.interceptContinue', {
            requestId: this._requestId,
            method: overrides.method,
            headers: overrides.headers,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined
        }).catch((error) => {
            // In certain cases, protocol will return error if the request was already canceled
            // or the page was closed. We should tolerate these errors.
            logger_1.logError(this.request._page);
        });
    }
    createResponse(responsePayload) {
        const getResponseBody = async () => {
            const response = await this._session.send('Network.getResponseBody', { requestId: this._requestId });
            return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
        };
        return new network.Response(this.request, responsePayload.status, responsePayload.statusText, headersObject(responsePayload.headers), getResponseBody);
    }
}
exports.WKInterceptableRequest = WKInterceptableRequest;
function headersObject(headers) {
    const result = {};
    for (const key of Object.keys(headers))
        result[key.toLowerCase()] = headers[key];
    return result;
}
//# sourceMappingURL=wkInterceptableRequest.js.map