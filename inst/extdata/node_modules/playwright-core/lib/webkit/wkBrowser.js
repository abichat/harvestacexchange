"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const browser_1 = require("../browser");
const browserContext_1 = require("../browserContext");
const events_1 = require("../events");
const helper_1 = require("../helper");
const network = require("../network");
const page_1 = require("../page");
const transport_1 = require("../transport");
const wkConnection_1 = require("./wkConnection");
const wkPage_1 = require("./wkPage");
const DEFAULT_USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.4 Safari/605.1.15';
class WKBrowser extends browser_1.BrowserBase {
    constructor(transport, logger, attachToDefaultContext) {
        super(logger);
        this._defaultContext = null;
        this._contexts = new Map();
        this._wkPages = new Map();
        this._firstPageCallback = () => { };
        this._connection = new wkConnection_1.WKConnection(transport, logger, this._onDisconnect.bind(this));
        this._browserSession = this._connection.browserSession;
        if (attachToDefaultContext)
            this._defaultContext = new WKBrowserContext(this, undefined, browserContext_1.validateBrowserContextOptions({}));
        this._eventListeners = [
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.pageProxyCreated', this._onPageProxyCreated.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.pageProxyDestroyed', this._onPageProxyDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.provisionalLoadFailed', event => this._onProvisionalLoadFailed(event)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.downloadCreated', this._onDownloadCreated.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Playwright.downloadFinished', this._onDownloadFinished.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, wkConnection_1.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this)),
        ];
        this._firstPagePromise = new Promise(resolve => this._firstPageCallback = resolve);
    }
    static async connect(transport, logger, slowMo = 0, attachToDefaultContext = false) {
        const browser = new WKBrowser(transport_1.SlowMoTransport.wrap(transport, slowMo), logger, attachToDefaultContext);
        return browser;
    }
    _onDisconnect() {
        for (const wkPage of this._wkPages.values())
            wkPage.dispose();
        for (const context of this._contexts.values())
            context._browserClosed();
        // Note: previous method uses pages to issue 'close' event on them, so we clear them after.
        this._wkPages.clear();
        this.emit(events_1.Events.Browser.Disconnected);
    }
    async newContext(options = {}) {
        options = browserContext_1.validateBrowserContextOptions(options);
        const { browserContextId } = await this._browserSession.send('Playwright.createContext');
        options.userAgent = options.userAgent || DEFAULT_USER_AGENT;
        const context = new WKBrowserContext(this, browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    async _waitForFirstPageTarget() {
        helper_1.assert(!this._wkPages.size);
        return this._firstPagePromise;
    }
    _onDownloadCreated(payload) {
        const page = this._wkPages.get(payload.pageProxyId);
        if (!page)
            return;
        const frameManager = page._page._frameManager;
        const frame = frameManager.frame(payload.frameId);
        if (frame) {
            // In some cases, e.g. blob url download, we receive only frameScheduledNavigation
            // but no signals that the navigation was canceled and replaced by download. Fix it
            // here by simulating cancelled provisional load which matches downloads from network.
            frameManager.provisionalLoadFailed(frame, '', 'Download is starting');
        }
        let originPage = page._initializedPage;
        // If it's a new window download, report it on the opener page.
        if (!originPage) {
            // Resume the page creation with an error. The page will automatically close right
            // after the download begins.
            page._firstNonInitialNavigationCommittedReject(new Error('Starting new page download'));
            if (page._opener)
                originPage = page._opener._initializedPage;
        }
        if (!originPage)
            return;
        this._downloadCreated(originPage, payload.uuid, payload.url);
    }
    _onDownloadFinished(payload) {
        this._downloadFinished(payload.uuid, payload.error);
    }
    _onPageProxyCreated(event) {
        const { pageProxyInfo } = event;
        const pageProxyId = pageProxyInfo.pageProxyId;
        let context = null;
        if (pageProxyInfo.browserContextId) {
            // FIXME: we don't know about the default context id, so assume that all targets from
            // unknown contexts are created in the 'default' context which can in practice be represented
            // by multiple actual contexts in WebKit. Solving this properly will require adding context
            // lifecycle events.
            context = this._contexts.get(pageProxyInfo.browserContextId) || null;
        }
        if (!context)
            context = this._defaultContext;
        if (!context)
            return;
        const pageProxySession = new wkConnection_1.WKSession(this._connection, pageProxyId, `The page has been closed.`, (message) => {
            this._connection.rawSend({ ...message, pageProxyId });
        });
        const opener = pageProxyInfo.openerId ? this._wkPages.get(pageProxyInfo.openerId) : undefined;
        const wkPage = new wkPage_1.WKPage(context, pageProxySession, opener || null);
        this._wkPages.set(pageProxyId, wkPage);
        if (opener && opener._initializedPage) {
            for (const signalBarrier of opener._initializedPage._frameManager._signalBarriers)
                signalBarrier.addPopup(wkPage.pageOrError());
        }
        wkPage.pageOrError().then(async () => {
            this._firstPageCallback();
            const page = wkPage._page;
            context.emit(events_1.Events.BrowserContext.Page, page);
            if (!opener)
                return;
            await opener.pageOrError();
            const openerPage = opener._page;
            if (!openerPage.isClosed())
                openerPage.emit(events_1.Events.Page.Popup, page);
        });
    }
    _onPageProxyDestroyed(event) {
        const pageProxyId = event.pageProxyId;
        const wkPage = this._wkPages.get(pageProxyId);
        if (!wkPage)
            return;
        wkPage.didClose();
        wkPage.dispose();
        this._wkPages.delete(pageProxyId);
    }
    _onPageProxyMessageReceived(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
            return;
        wkPage.dispatchMessageToSession(event.message);
    }
    _onProvisionalLoadFailed(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
            return;
        wkPage.handleProvisionalLoadFailed(event);
    }
    isConnected() {
        return !this._connection.isClosed();
    }
    _disconnect() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._connection.close();
    }
}
exports.WKBrowser = WKBrowser;
class WKBrowserContext extends browserContext_1.BrowserContextBase {
    constructor(browser, browserContextId, options) {
        super(browser, options);
        this._browser = browser;
        this._browserContextId = browserContextId;
        this._evaluateOnNewDocumentSources = [];
    }
    async _initialize() {
        const browserContextId = this._browserContextId;
        const promises = [
            this._browser._browserSession.send('Playwright.setDownloadBehavior', {
                behavior: this._options.acceptDownloads ? 'allow' : 'deny',
                downloadPath: this._browser._downloadsPath,
                browserContextId
            })
        ];
        if (this._options.ignoreHTTPSErrors)
            promises.push(this._browser._browserSession.send('Playwright.setIgnoreCertificateErrors', { browserContextId, ignore: true }));
        if (this._options.locale)
            promises.push(this._browser._browserSession.send('Playwright.setLanguages', { browserContextId, languages: [this._options.locale] }));
        if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
        if (this._options.geolocation)
            promises.push(this.setGeolocation(this._options.geolocation));
        if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
        if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
        await Promise.all(promises);
    }
    _wkPages() {
        return Array.from(this._browser._wkPages.values()).filter(wkPage => wkPage._browserContext === this);
    }
    pages() {
        return this._wkPages().map(wkPage => wkPage._initializedPage).filter(pageOrNull => !!pageOrNull);
    }
    async newPage() {
        browserContext_1.assertBrowserContextIsNotOwned(this);
        const { pageProxyId } = await this._browser._browserSession.send('Playwright.createPage', { browserContextId: this._browserContextId });
        const wkPage = this._browser._wkPages.get(pageProxyId);
        const result = await wkPage.pageOrError();
        if (result instanceof page_1.Page) {
            if (result.isClosed())
                throw new Error('Page has been closed.');
            return result;
        }
        throw result;
    }
    async cookies(urls) {
        const { cookies } = await this._browser._browserSession.send('Playwright.getAllCookies', { browserContextId: this._browserContextId });
        return network.filterCookies(cookies.map((c) => {
            const copy = { ...c };
            copy.expires = c.expires === -1 ? -1 : c.expires / 1000;
            delete copy.session;
            return copy;
        }), urls);
    }
    async addCookies(cookies) {
        const cc = network.rewriteCookies(cookies).map(c => ({
            ...c,
            session: c.expires === -1 || c.expires === undefined,
            expires: c.expires && c.expires !== -1 ? c.expires * 1000 : c.expires
        }));
        await this._browser._browserSession.send('Playwright.setCookies', { cookies: cc, browserContextId: this._browserContextId });
    }
    async clearCookies() {
        await this._browser._browserSession.send('Playwright.deleteAllCookies', { browserContextId: this._browserContextId });
    }
    async _doGrantPermissions(origin, permissions) {
        await Promise.all(this.pages().map(page => page._delegate._grantPermissions(origin, permissions)));
    }
    async _doClearPermissions() {
        await Promise.all(this.pages().map(page => page._delegate._clearPermissions()));
    }
    async setGeolocation(geolocation) {
        if (geolocation)
            geolocation = browserContext_1.verifyGeolocation(geolocation);
        this._options.geolocation = geolocation || undefined;
        const payload = geolocation ? { ...geolocation, timestamp: Date.now() } : undefined;
        await this._browser._browserSession.send('Playwright.setGeolocationOverride', { browserContextId: this._browserContextId, geolocation: payload });
    }
    async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = network.verifyHeaders(headers);
        for (const page of this.pages())
            await page._delegate.updateExtraHTTPHeaders();
    }
    async setOffline(offline) {
        this._options.offline = offline;
        for (const page of this.pages())
            await page._delegate.updateOffline();
    }
    async setHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials || undefined;
        for (const page of this.pages())
            await page._delegate.updateHttpCredentials();
    }
    async addInitScript(script, arg) {
        const source = await helper_1.helper.evaluationScript(script, arg);
        this._evaluateOnNewDocumentSources.push(source);
        for (const page of this.pages())
            await page._delegate._updateBootstrapScript();
    }
    async exposeFunction(name, playwrightFunction) {
        for (const page of this.pages()) {
            if (page._pageBindings.has(name))
                throw new Error(`Function "${name}" has been already registered in one of the pages`);
        }
        if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
        const binding = new page_1.PageBinding(name, playwrightFunction);
        this._pageBindings.set(name, binding);
        for (const page of this.pages())
            await page._delegate.exposeBinding(binding);
    }
    async route(url, handler) {
        this._routes.push({ url, handler });
        for (const page of this.pages())
            await page._delegate.updateRequestInterception();
    }
    async unroute(url, handler) {
        this._routes = this._routes.filter(route => route.url !== url || (handler && route.handler !== handler));
        for (const page of this.pages())
            await page._delegate.updateRequestInterception();
    }
    async close() {
        if (this._closed)
            return;
        if (!this._browserContextId) {
            // Default context is only created in 'persistent' mode and closing it should close
            // the browser.
            await this._browser.close();
            return;
        }
        await this._browser._browserSession.send('Playwright.deleteContext', { browserContextId: this._browserContextId });
        this._browser._contexts.delete(this._browserContextId);
        await this._didCloseInternal();
    }
}
exports.WKBrowserContext = WKBrowserContext;
//# sourceMappingURL=wkBrowser.js.map