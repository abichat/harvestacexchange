"use strict";
/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const browser_1 = require("../browser");
const browserContext_1 = require("../browserContext");
const events_1 = require("../events");
const helper_1 = require("../helper");
const network = require("../network");
const page_1 = require("../page");
const transport_1 = require("../transport");
const ffConnection_1 = require("./ffConnection");
const ffNetworkManager_1 = require("./ffNetworkManager");
const ffPage_1 = require("./ffPage");
class FFBrowser extends browser_1.BrowserBase {
    constructor(connection, logger, isPersistent) {
        super(logger);
        this._defaultContext = null;
        this._firstPageCallback = () => { };
        this._connection = connection;
        this._ffPages = new Map();
        if (isPersistent)
            this._defaultContext = new FFBrowserContext(this, null, browserContext_1.validateBrowserContextOptions({}));
        this._contexts = new Map();
        this._connection.on(ffConnection_1.ConnectionEvents.Disconnected, () => {
            for (const context of this._contexts.values())
                context._browserClosed();
            this.emit(events_1.Events.Browser.Disconnected);
        });
        this._eventListeners = [
            helper_1.helper.addEventListener(this._connection, 'Browser.attachedToTarget', this._onAttachedToTarget.bind(this)),
            helper_1.helper.addEventListener(this._connection, 'Browser.detachedFromTarget', this._onDetachedFromTarget.bind(this)),
            helper_1.helper.addEventListener(this._connection, 'Browser.downloadCreated', this._onDownloadCreated.bind(this)),
            helper_1.helper.addEventListener(this._connection, 'Browser.downloadFinished', this._onDownloadFinished.bind(this)),
        ];
        this._firstPagePromise = new Promise(f => this._firstPageCallback = f);
    }
    static async connect(transport, logger, attachToDefaultContext, slowMo) {
        const connection = new ffConnection_1.FFConnection(transport_1.SlowMoTransport.wrap(transport, slowMo), logger);
        const browser = new FFBrowser(connection, logger, attachToDefaultContext);
        await connection.send('Browser.enable', { attachToDefaultContext });
        return browser;
    }
    isConnected() {
        return !this._connection._closed;
    }
    async newContext(options = {}) {
        options = browserContext_1.validateBrowserContextOptions(options);
        let viewport;
        if (options.viewport) {
            // TODO: remove isMobile from the protocol?
            if (options.isMobile)
                throw new Error('options.isMobile is not supported in Firefox');
            viewport = {
                viewportSize: { width: options.viewport.width, height: options.viewport.height },
                deviceScaleFactor: options.deviceScaleFactor || 1,
                isMobile: false,
                hasTouch: !!options.hasTouch,
            };
        }
        else if (options.viewport !== null) {
            viewport = {
                viewportSize: { width: 1280, height: 720 },
                deviceScaleFactor: 1,
                isMobile: false,
                hasTouch: false,
            };
        }
        const { browserContextId } = await this._connection.send('Browser.createBrowserContext', {
            userAgent: options.userAgent,
            bypassCSP: options.bypassCSP,
            ignoreHTTPSErrors: options.ignoreHTTPSErrors,
            javaScriptDisabled: options.javaScriptEnabled === false ? true : undefined,
            viewport,
            locale: options.locale,
            timezoneId: options.timezoneId,
            removeOnDetach: true,
            downloadOptions: {
                behavior: options.acceptDownloads ? 'saveToDisk' : 'cancel',
                downloadsDir: this._downloadsPath,
            },
        });
        const context = new FFBrowserContext(this, browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    _onDetachedFromTarget(payload) {
        const ffPage = this._ffPages.get(payload.targetId);
        this._ffPages.delete(payload.targetId);
        ffPage.didClose();
    }
    _onAttachedToTarget(payload) {
        const { targetId, browserContextId, openerId, type } = payload.targetInfo;
        helper_1.assert(type === 'page');
        const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
        helper_1.assert(context, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);
        const session = this._connection.createSession(payload.sessionId, type);
        const opener = openerId ? this._ffPages.get(openerId) : null;
        const ffPage = new ffPage_1.FFPage(session, context, opener);
        this._ffPages.set(targetId, ffPage);
        if (opener && opener._initializedPage) {
            for (const signalBarrier of opener._initializedPage._frameManager._signalBarriers)
                signalBarrier.addPopup(ffPage.pageOrError());
        }
        ffPage.pageOrError().then(async () => {
            this._firstPageCallback();
            const page = ffPage._page;
            context.emit(events_1.Events.BrowserContext.Page, page);
            if (!opener)
                return;
            const openerPage = await opener.pageOrError();
            if (openerPage instanceof page_1.Page && !openerPage.isClosed())
                openerPage.emit(events_1.Events.Page.Popup, page);
        });
    }
    _onDownloadCreated(payload) {
        const ffPage = this._ffPages.get(payload.pageTargetId);
        helper_1.assert(ffPage);
        if (!ffPage)
            return;
        let originPage = ffPage._initializedPage;
        // If it's a new window download, report it on the opener page.
        if (!originPage) {
            // Resume the page creation with an error. The page will automatically close right
            // after the download begins.
            ffPage._pageCallback(new Error('Starting new page download'));
            if (ffPage._opener)
                originPage = ffPage._opener._initializedPage;
        }
        if (!originPage)
            return;
        this._downloadCreated(originPage, payload.uuid, payload.url);
    }
    _onDownloadFinished(payload) {
        const error = payload.canceled ? 'canceled' : payload.error;
        this._downloadFinished(payload.uuid, error);
    }
    _disconnect() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._connection.close();
    }
}
exports.FFBrowser = FFBrowser;
class FFBrowserContext extends browserContext_1.BrowserContextBase {
    constructor(browser, browserContextId, options) {
        super(browser, options);
        this._browser = browser;
        this._browserContextId = browserContextId;
        this._evaluateOnNewDocumentSources = [];
    }
    async _initialize() {
        if (this._options.permissions)
            await this.grantPermissions(this._options.permissions);
        if (this._options.extraHTTPHeaders || this._options.locale)
            await this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || {});
        if (this._options.httpCredentials)
            await this.setHTTPCredentials(this._options.httpCredentials);
        if (this._options.geolocation)
            await this.setGeolocation(this._options.geolocation);
        if (this._options.offline)
            await this.setOffline(this._options.offline);
        if (this._options.colorScheme)
            await this._setColorScheme(this._options.colorScheme);
    }
    _ffPages() {
        return Array.from(this._browser._ffPages.values()).filter(ffPage => ffPage._browserContext === this);
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    pages() {
        return this._ffPages().map(ffPage => ffPage._initializedPage).filter(pageOrNull => !!pageOrNull);
    }
    async newPage() {
        browserContext_1.assertBrowserContextIsNotOwned(this);
        const { targetId } = await this._browser._connection.send('Browser.newPage', {
            browserContextId: this._browserContextId || undefined
        }).catch(e => {
            if (e.message.includes('Failed to override timezone'))
                throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
            throw e;
        });
        const ffPage = this._browser._ffPages.get(targetId);
        const pageOrError = await ffPage.pageOrError();
        if (pageOrError instanceof page_1.Page) {
            if (pageOrError.isClosed())
                throw new Error('Page has been closed.');
            return pageOrError;
        }
        throw pageOrError;
    }
    async cookies(urls) {
        const { cookies } = await this._browser._connection.send('Browser.getCookies', { browserContextId: this._browserContextId || undefined });
        return network.filterCookies(cookies.map(c => {
            const copy = { ...c };
            delete copy.size;
            delete copy.session;
            return copy;
        }), urls);
    }
    async addCookies(cookies) {
        await this._browser._connection.send('Browser.setCookies', { browserContextId: this._browserContextId || undefined, cookies: network.rewriteCookies(cookies) });
    }
    async clearCookies() {
        await this._browser._connection.send('Browser.clearCookies', { browserContextId: this._browserContextId || undefined });
    }
    async _doGrantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
            ['geolocation', 'geo'],
            ['persistent-storage', 'persistent-storage'],
            ['push', 'push'],
            ['notifications', 'desktop-notification'],
        ]);
        const filtered = permissions.map(permission => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
                throw new Error('Unknown permission: ' + permission);
            return protocolPermission;
        });
        await this._browser._connection.send('Browser.grantPermissions', { origin: origin, browserContextId: this._browserContextId || undefined, permissions: filtered });
    }
    async _doClearPermissions() {
        await this._browser._connection.send('Browser.resetPermissions', { browserContextId: this._browserContextId || undefined });
    }
    async setGeolocation(geolocation) {
        if (geolocation)
            geolocation = browserContext_1.verifyGeolocation(geolocation);
        this._options.geolocation = geolocation || undefined;
        await this._browser._connection.send('Browser.setGeolocationOverride', { browserContextId: this._browserContextId || undefined, geolocation });
    }
    async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = network.verifyHeaders(headers);
        const allHeaders = { ...this._options.extraHTTPHeaders };
        if (this._options.locale)
            allHeaders['Accept-Language'] = this._options.locale;
        await this._browser._connection.send('Browser.setExtraHTTPHeaders', { browserContextId: this._browserContextId || undefined, headers: ffNetworkManager_1.headersArray(allHeaders) });
    }
    async setOffline(offline) {
        this._options.offline = offline;
        await this._browser._connection.send('Browser.setOnlineOverride', { browserContextId: this._browserContextId || undefined, override: offline ? 'offline' : 'online' });
    }
    async _setColorScheme(colorScheme) {
        await this._browser._connection.send('Browser.setColorScheme', { browserContextId: this._browserContextId || undefined, colorScheme });
    }
    async setHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials || undefined;
        await this._browser._connection.send('Browser.setHTTPCredentials', { browserContextId: this._browserContextId || undefined, credentials: httpCredentials });
    }
    async addInitScript(script, arg) {
        const source = await helper_1.helper.evaluationScript(script, arg);
        this._evaluateOnNewDocumentSources.push(source);
        await this._browser._connection.send('Browser.addScriptToEvaluateOnNewDocument', { browserContextId: this._browserContextId || undefined, script: source });
    }
    async exposeFunction(name, playwrightFunction) {
        for (const page of this.pages()) {
            if (page._pageBindings.has(name))
                throw new Error(`Function "${name}" has been already registered in one of the pages`);
        }
        if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
        const binding = new page_1.PageBinding(name, playwrightFunction);
        this._pageBindings.set(name, binding);
        await this._browser._connection.send('Browser.addBinding', { browserContextId: this._browserContextId || undefined, name, script: binding.source });
    }
    async route(url, handler) {
        this._routes.push({ url, handler });
        if (this._routes.length === 1)
            await this._browser._connection.send('Browser.setRequestInterception', { browserContextId: this._browserContextId || undefined, enabled: true });
    }
    async unroute(url, handler) {
        this._routes = this._routes.filter(route => route.url !== url || (handler && route.handler !== handler));
        if (this._routes.length === 0)
            await this._browser._connection.send('Browser.setRequestInterception', { browserContextId: this._browserContextId || undefined, enabled: false });
    }
    async close() {
        if (this._closed)
            return;
        if (!this._browserContextId) {
            // Default context is only created in 'persistent' mode and closing it should close
            // the browser.
            await this._browser.close();
            return;
        }
        await this._browser._connection.send('Browser.removeBrowserContext', { browserContextId: this._browserContextId });
        this._browser._contexts.delete(this._browserContextId);
        await this._didCloseInternal();
    }
}
exports.FFBrowserContext = FFBrowserContext;
//# sourceMappingURL=ffBrowser.js.map