"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const browser_1 = require("../browser");
const browserContext_1 = require("../browserContext");
const events_1 = require("../events");
const helper_1 = require("../helper");
const network = require("../network");
const page_1 = require("../page");
const transport_1 = require("../transport");
const crConnection_1 = require("./crConnection");
const crPage_1 = require("./crPage");
const crProtocolHelper_1 = require("./crProtocolHelper");
const events_2 = require("./events");
const crExecutionContext_1 = require("./crExecutionContext");
const logger_1 = require("../logger");
class CRBrowser extends browser_1.BrowserBase {
    constructor(connection, logger, isPersistent, isHeadful) {
        super(logger);
        this._clientRootSessionPromise = null;
        this._defaultContext = null;
        this._contexts = new Map();
        this._crPages = new Map();
        this._backgroundPages = new Map();
        this._serviceWorkers = new Map();
        this._firstPageCallback = () => { };
        this._tracingRecording = false;
        this._tracingPath = '';
        this._connection = connection;
        this._session = this._connection.rootSession;
        if (isPersistent)
            this._defaultContext = new CRBrowserContext(this, null, browserContext_1.validateBrowserContextOptions({}));
        this._isHeadful = isHeadful;
        this._connection.on(crConnection_1.ConnectionEvents.Disconnected, () => {
            for (const context of this._contexts.values())
                context._browserClosed();
            this.emit(events_1.Events.Browser.Disconnected);
        });
        this._session.on('Target.attachedToTarget', this._onAttachedToTarget.bind(this));
        this._session.on('Target.detachedFromTarget', this._onDetachedFromTarget.bind(this));
        this._firstPagePromise = new Promise(f => this._firstPageCallback = f);
    }
    static async connect(transport, isPersistent, logger, options = {}) {
        const connection = new crConnection_1.CRConnection(transport_1.SlowMoTransport.wrap(transport, options.slowMo), logger);
        const browser = new CRBrowser(connection, logger, isPersistent, !options.headless);
        const session = connection.rootSession;
        if (!isPersistent) {
            await session.send('Target.setAutoAttach', { autoAttach: true, waitForDebuggerOnStart: true, flatten: true });
            return browser;
        }
        const existingTargetAttachPromises = [];
        // First page, background pages and their service workers in the persistent context
        // are created automatically and may be initialized before we enable auto-attach.
        function attachToExistingPage({ targetInfo }) {
            if (targetInfo.type !== 'page' && targetInfo.type !== 'background_page' && targetInfo.type !== 'service_worker')
                return;
            // TODO: should we handle the error during 'Target.attachToTarget'? Can the target disappear?
            existingTargetAttachPromises.push(session.send('Target.attachToTarget', { targetId: targetInfo.targetId, flatten: true }));
        }
        session.on('Target.targetCreated', attachToExistingPage);
        const startDiscover = session.send('Target.setDiscoverTargets', { discover: true });
        const autoAttachAndStopDiscover = session.send('Target.setAutoAttach', { autoAttach: true, waitForDebuggerOnStart: true, flatten: true }).then(() => {
            // All targets collected before setAutoAttach response will not be auto-attached, the rest will be.
            // TODO: We should fix this upstream and remove this tricky logic.
            session.off('Target.targetCreated', attachToExistingPage);
            return session.send('Target.setDiscoverTargets', { discover: false });
        });
        await Promise.all([
            startDiscover,
            autoAttachAndStopDiscover,
        ]);
        // Wait for initial targets to arrive.
        await Promise.all(existingTargetAttachPromises);
        return browser;
    }
    async newContext(options = {}) {
        options = browserContext_1.validateBrowserContextOptions(options);
        const { browserContextId } = await this._session.send('Target.createBrowserContext', { disposeOnDetach: true });
        const context = new CRBrowserContext(this, browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    _onAttachedToTarget({ targetInfo, sessionId, waitingForDebugger }) {
        if (targetInfo.type === 'browser')
            return;
        const session = this._connection.session(sessionId);
        helper_1.assert(targetInfo.browserContextId, 'targetInfo: ' + JSON.stringify(targetInfo, null, 2));
        let context = this._contexts.get(targetInfo.browserContextId) || null;
        if (!context) {
            // TODO: auto attach only to pages from our contexts.
            // assert(this._defaultContext);
            context = this._defaultContext;
        }
        if (targetInfo.type === 'other' || !context) {
            if (waitingForDebugger) {
                // Ideally, detaching should resume any target, but there is a bug in the backend.
                session.send('Runtime.runIfWaitingForDebugger').catch(logger_1.logError(this)).then(() => {
                    this._session.send('Target.detachFromTarget', { sessionId }).catch(logger_1.logError(this));
                });
            }
            return;
        }
        helper_1.assert(!this._crPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);
        helper_1.assert(!this._backgroundPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);
        helper_1.assert(!this._serviceWorkers.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);
        if (targetInfo.type === 'background_page') {
            const backgroundPage = new crPage_1.CRPage(session, targetInfo.targetId, context, null, false);
            this._backgroundPages.set(targetInfo.targetId, backgroundPage);
            backgroundPage.pageOrError().then(() => {
                context.emit(events_2.Events.CRBrowserContext.BackgroundPage, backgroundPage._page);
            });
            return;
        }
        if (targetInfo.type === 'page') {
            const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
            const crPage = new crPage_1.CRPage(session, targetInfo.targetId, context, opener, this._isHeadful);
            this._crPages.set(targetInfo.targetId, crPage);
            if (opener && opener._initializedPage) {
                for (const signalBarrier of opener._initializedPage._frameManager._signalBarriers)
                    signalBarrier.addPopup(crPage.pageOrError());
            }
            crPage.pageOrError().then(() => {
                this._firstPageCallback();
                context.emit(events_1.Events.BrowserContext.Page, crPage._page);
                if (opener) {
                    opener.pageOrError().then(openerPage => {
                        if (openerPage instanceof page_1.Page && !openerPage.isClosed())
                            openerPage.emit(events_1.Events.Page.Popup, crPage._page);
                    });
                }
            });
            return;
        }
        if (targetInfo.type === 'service_worker') {
            const serviceWorker = new CRServiceWorker(context, session, targetInfo.url);
            this._serviceWorkers.set(targetInfo.targetId, serviceWorker);
            context.emit(events_2.Events.CRBrowserContext.ServiceWorker, serviceWorker);
            return;
        }
        helper_1.assert(false, 'Unknown target type: ' + targetInfo.type);
    }
    _onDetachedFromTarget(payload) {
        const targetId = payload.targetId;
        const crPage = this._crPages.get(targetId);
        if (crPage) {
            this._crPages.delete(targetId);
            crPage.didClose();
            return;
        }
        const backgroundPage = this._backgroundPages.get(targetId);
        if (backgroundPage) {
            this._backgroundPages.delete(targetId);
            backgroundPage.didClose();
            return;
        }
        const serviceWorker = this._serviceWorkers.get(targetId);
        if (serviceWorker) {
            this._serviceWorkers.delete(targetId);
            serviceWorker.emit(events_1.Events.Worker.Close);
            return;
        }
    }
    async _closePage(crPage) {
        await this._session.send('Target.closeTarget', { targetId: crPage._targetId });
    }
    _disconnect() {
        this._connection.close();
    }
    async newBrowserCDPSession() {
        return await this._connection.createBrowserSession();
    }
    async startTracing(page, options = {}) {
        helper_1.assert(!this._tracingRecording, 'Cannot start recording trace while already recording trace.');
        this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;
        const defaultCategories = [
            '-*', 'devtools.timeline', 'v8.execute', 'disabled-by-default-devtools.timeline',
            'disabled-by-default-devtools.timeline.frame', 'toplevel',
            'blink.console', 'blink.user_timing', 'latencyInfo', 'disabled-by-default-devtools.timeline.stack',
            'disabled-by-default-v8.cpu_profiler', 'disabled-by-default-v8.cpu_profiler.hires'
        ];
        const { path = null, screenshots = false, categories = defaultCategories, } = options;
        if (screenshots)
            categories.push('disabled-by-default-devtools.screenshot');
        this._tracingPath = path;
        this._tracingRecording = true;
        await this._tracingClient.send('Tracing.start', {
            transferMode: 'ReturnAsStream',
            categories: categories.join(',')
        });
    }
    async stopTracing() {
        helper_1.assert(this._tracingClient, 'Tracing was not started.');
        const [event] = await Promise.all([
            new Promise(f => this._tracingClient.once('Tracing.tracingComplete', f)),
            this._tracingClient.send('Tracing.end')
        ]);
        const result = await crProtocolHelper_1.readProtocolStream(this._tracingClient, event.stream, this._tracingPath);
        this._tracingRecording = false;
        return result;
    }
    isConnected() {
        return !this._connection._closed;
    }
    async _clientRootSession() {
        if (!this._clientRootSessionPromise)
            this._clientRootSessionPromise = this._connection.createBrowserSession();
        return this._clientRootSessionPromise;
    }
}
exports.CRBrowser = CRBrowser;
class CRServiceWorker extends page_1.Worker {
    constructor(browserContext, session, url) {
        super(browserContext, url);
        this._browserContext = browserContext;
        session.once('Runtime.executionContextCreated', event => {
            this._createExecutionContext(new crExecutionContext_1.CRExecutionContext(session, event.context));
        });
        // This might fail if the target is closed before we receive all execution contexts.
        session.send('Runtime.enable', {}).catch(e => { });
        session.send('Runtime.runIfWaitingForDebugger').catch(e => { });
    }
}
class CRBrowserContext extends browserContext_1.BrowserContextBase {
    constructor(browser, browserContextId, options) {
        super(browser, options);
        this._browser = browser;
        this._browserContextId = browserContextId;
        this._evaluateOnNewDocumentSources = [];
    }
    async _initialize() {
        const promises = [
            this._browser._session.send('Browser.setDownloadBehavior', {
                behavior: this._options.acceptDownloads ? 'allowAndName' : 'deny',
                browserContextId: this._browserContextId || undefined,
                downloadPath: this._browser._downloadsPath
            })
        ];
        if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
        if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
        if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
        await Promise.all(promises);
    }
    pages() {
        const result = [];
        for (const crPage of this._browser._crPages.values()) {
            if (crPage._browserContext === this && crPage._initializedPage)
                result.push(crPage._initializedPage);
        }
        return result;
    }
    async newPage() {
        browserContext_1.assertBrowserContextIsNotOwned(this);
        const { targetId } = await this._browser._session.send('Target.createTarget', { url: 'about:blank', browserContextId: this._browserContextId || undefined });
        const crPage = this._browser._crPages.get(targetId);
        const result = await crPage.pageOrError();
        if (result instanceof page_1.Page) {
            if (result.isClosed())
                throw new Error('Page has been closed.');
            return result;
        }
        throw result;
    }
    async cookies(urls) {
        const { cookies } = await this._browser._session.send('Storage.getCookies', { browserContextId: this._browserContextId || undefined });
        return network.filterCookies(cookies.map(c => {
            const copy = { sameSite: 'None', ...c };
            delete copy.size;
            delete copy.priority;
            delete copy.session;
            return copy;
        }), urls);
    }
    async addCookies(cookies) {
        cookies = cookies.map(c => {
            const copy = { ...c };
            // Working around setter issue in Chrome. Cookies are now None by default.
            if (copy.sameSite === 'None')
                delete copy.sameSite;
            return copy;
        });
        await this._browser._session.send('Storage.setCookies', { cookies: network.rewriteCookies(cookies), browserContextId: this._browserContextId || undefined });
    }
    async clearCookies() {
        await this._browser._session.send('Storage.clearCookies', { browserContextId: this._browserContextId || undefined });
    }
    async _doGrantPermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
            ['geolocation', 'geolocation'],
            ['midi', 'midi'],
            ['notifications', 'notifications'],
            ['camera', 'videoCapture'],
            ['microphone', 'audioCapture'],
            ['background-sync', 'backgroundSync'],
            ['ambient-light-sensor', 'sensors'],
            ['accelerometer', 'sensors'],
            ['gyroscope', 'sensors'],
            ['magnetometer', 'sensors'],
            ['accessibility-events', 'accessibilityEvents'],
            ['clipboard-read', 'clipboardReadWrite'],
            ['clipboard-write', 'clipboardSanitizedWrite'],
            ['payment-handler', 'paymentHandler'],
            // chrome-specific permissions we have.
            ['midi-sysex', 'midiSysex'],
        ]);
        const filtered = permissions.map(permission => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
                throw new Error('Unknown permission: ' + permission);
            return protocolPermission;
        });
        await this._browser._session.send('Browser.grantPermissions', { origin: origin === '*' ? undefined : origin, browserContextId: this._browserContextId || undefined, permissions: filtered });
    }
    async _doClearPermissions() {
        await this._browser._session.send('Browser.resetPermissions', { browserContextId: this._browserContextId || undefined });
    }
    async setGeolocation(geolocation) {
        if (geolocation)
            geolocation = browserContext_1.verifyGeolocation(geolocation);
        this._options.geolocation = geolocation || undefined;
        for (const page of this.pages())
            await page._delegate.updateGeolocation();
    }
    async setExtraHTTPHeaders(headers) {
        this._options.extraHTTPHeaders = network.verifyHeaders(headers);
        for (const page of this.pages())
            await page._delegate.updateExtraHTTPHeaders();
    }
    async setOffline(offline) {
        this._options.offline = offline;
        for (const page of this.pages())
            await page._delegate.updateOffline();
    }
    async setHTTPCredentials(httpCredentials) {
        this._options.httpCredentials = httpCredentials || undefined;
        for (const page of this.pages())
            await page._delegate.updateHttpCredentials();
    }
    async addInitScript(script, arg) {
        const source = await helper_1.helper.evaluationScript(script, arg);
        this._evaluateOnNewDocumentSources.push(source);
        for (const page of this.pages())
            await page._delegate.evaluateOnNewDocument(source);
    }
    async exposeFunction(name, playwrightFunction) {
        for (const page of this.pages()) {
            if (page._pageBindings.has(name))
                throw new Error(`Function "${name}" has been already registered in one of the pages`);
        }
        if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
        const binding = new page_1.PageBinding(name, playwrightFunction);
        this._pageBindings.set(name, binding);
        for (const page of this.pages())
            await page._delegate.exposeBinding(binding);
    }
    async route(url, handler) {
        this._routes.push({ url, handler });
        for (const page of this.pages())
            await page._delegate.updateRequestInterception();
    }
    async unroute(url, handler) {
        this._routes = this._routes.filter(route => route.url !== url || (handler && route.handler !== handler));
        for (const page of this.pages())
            await page._delegate.updateRequestInterception();
    }
    async close() {
        if (this._closed)
            return;
        if (!this._browserContextId) {
            // Default context is only created in 'persistent' mode and closing it should close
            // the browser.
            await this._browser.close();
            return;
        }
        await this._browser._session.send('Target.disposeBrowserContext', { browserContextId: this._browserContextId });
        this._browser._contexts.delete(this._browserContextId);
        await this._didCloseInternal();
    }
    backgroundPages() {
        const result = [];
        for (const backgroundPage of this._browser._backgroundPages.values()) {
            if (backgroundPage._browserContext === this && backgroundPage._initializedPage)
                result.push(backgroundPage._initializedPage);
        }
        return result;
    }
    serviceWorkers() {
        return Array.from(this._browser._serviceWorkers.values()).filter(serviceWorker => serviceWorker._browserContext === this);
    }
    async newCDPSession(page) {
        const targetId = page._delegate._targetId;
        const rootSession = await this._browser._clientRootSession();
        const { sessionId } = await rootSession.send('Target.attachToTarget', { targetId, flatten: true });
        return this._browser._connection.session(sessionId);
    }
}
exports.CRBrowserContext = CRBrowserContext;
//# sourceMappingURL=crBrowser.js.map